import {
  Search_default
} from "./chunk-TYVG5O73.js";
import {
  DisabledContext_default,
  FormItemInputContext,
  Input_default,
  devUseWarning,
  getAllowClear_default,
  getMergedStatus,
  getStatusClassNames,
  initComponentToken,
  initInputToken,
  style_default2 as style_default,
  triggerFocus,
  useCSSVarCls_default,
  useRemovePasswordTimeout,
  useSize_default,
  useVariants_default
} from "./chunk-P6EABO6W.js";
import {
  ConfigContext,
  genStyleHooks
} from "./chunk-PE3ERFFR.js";
import {
  EyeInvisibleOutlined_default,
  EyeOutlined_default
} from "./chunk-D63KSZUY.js";
import {
  es_default2 as es_default,
  init_es2
} from "./chunk-Y2DVVYJY.js";
import {
  init_omit,
  init_raf,
  omit,
  raf_default
} from "./chunk-OJSKDBQJ.js";
import {
  _toConsumableArray,
  init_es2 as init_es,
  init_toConsumableArray,
  merge2 as merge,
  useEvent
} from "./chunk-MVO3W7HC.js";
import {
  require_classnames
} from "./chunk-NTCEPQPR.js";
import {
  _objectSpread2,
  composeRef,
  init_objectSpread2,
  init_ref
} from "./chunk-NMHO3GMT.js";
import {
  require_react
} from "./chunk-MOJUAYT3.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/antd/es/input/Group.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var import_classnames = __toESM(require_classnames());
var Group = (props) => {
  const {
    getPrefixCls,
    direction
  } = (0, import_react.useContext)(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className
  } = props;
  const prefixCls = getPrefixCls("input-group", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input");
  const [wrapCSSVar, hashId] = style_default(inputPrefixCls);
  const cls = (0, import_classnames.default)(prefixCls, {
    [`${prefixCls}-lg`]: props.size === "large",
    [`${prefixCls}-sm`]: props.size === "small",
    [`${prefixCls}-compact`]: props.compact,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, className);
  const formItemContext = (0, import_react.useContext)(FormItemInputContext);
  const groupFormItemContext = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, formItemContext), {
    isFormItemInput: false
  }), [formItemContext]);
  if (true) {
    const warning = devUseWarning("Input.Group");
    warning.deprecated(false, "Input.Group", "Space.Compact");
  }
  return wrapCSSVar(React.createElement("span", {
    className: cls,
    style: props.style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    onFocus: props.onFocus,
    onBlur: props.onBlur
  }, React.createElement(FormItemInputContext.Provider, {
    value: groupFormItemContext
  }, props.children)));
};
var Group_default = Group;

// node_modules/antd/es/input/OTP/index.js
init_toConsumableArray();
var React3 = __toESM(require_react());
var import_classnames2 = __toESM(require_classnames());
init_es();

// node_modules/rc-util/es/pickAttrs.js
init_objectSpread2();
var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key, prefix) {
  return key.indexOf(prefix) === 0;
}
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function(key) {
    if (
      // Aria
      mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
      mergedConfig.data && match(key, dataPrefix) || // Attr
      mergedConfig.attr && propList.includes(key)
    ) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}

// node_modules/antd/es/input/style/otp.js
var genOTPStyle = (token) => {
  const {
    componentCls,
    paddingXS
  } = token;
  return {
    [componentCls]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: paddingXS,
      "&-rtl": {
        direction: "rtl"
      },
      [`${componentCls}-input`]: {
        textAlign: "center",
        paddingInline: token.paddingXXS
      },
      // ================= Size =================
      [`&${componentCls}-sm ${componentCls}-input`]: {
        paddingInline: token.calc(token.paddingXXS).div(2).equal()
      },
      [`&${componentCls}-lg ${componentCls}-input`]: {
        paddingInline: token.paddingXS
      }
    }
  };
};
var otp_default = genStyleHooks(["Input", "OTP"], (token) => {
  const inputToken = merge(token, initInputToken(token));
  return [genOTPStyle(inputToken)];
}, initComponentToken);

// node_modules/antd/es/input/OTP/OTPInput.js
var React2 = __toESM(require_react());
init_raf();
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var OTPInput = React2.forwardRef((props, ref) => {
  const {
    value,
    onChange,
    onActiveChange,
    index,
    mask
  } = props, restProps = __rest(props, ["value", "onChange", "onActiveChange", "index", "mask"]);
  const internalValue = value && typeof mask === "string" ? mask : value;
  const onInternalChange = (e) => {
    onChange(index, e.target.value);
  };
  const inputRef = React2.useRef(null);
  React2.useImperativeHandle(ref, () => inputRef.current);
  const syncSelection = () => {
    raf_default(() => {
      var _a;
      const inputEle = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input;
      if (document.activeElement === inputEle && inputEle) {
        inputEle.select();
      }
    });
  };
  const onInternalKeyDown = (_ref) => {
    let {
      key
    } = _ref;
    if (key === "ArrowLeft") {
      onActiveChange(index - 1);
    } else if (key === "ArrowRight") {
      onActiveChange(index + 1);
    }
    syncSelection();
  };
  const onInternalKeyUp = (e) => {
    if (e.key === "Backspace" && !value) {
      onActiveChange(index - 1);
    }
    syncSelection();
  };
  return React2.createElement(Input_default, Object.assign({}, restProps, {
    ref: inputRef,
    value: internalValue,
    onInput: onInternalChange,
    onFocus: syncSelection,
    onKeyDown: onInternalKeyDown,
    onKeyUp: onInternalKeyUp,
    onMouseDown: syncSelection,
    onMouseUp: syncSelection,
    type: mask === true ? "password" : "text"
  }));
});
var OTPInput_default = OTPInput;

// node_modules/antd/es/input/OTP/index.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function strToArr(str) {
  return (str || "").split("");
}
var OTP = React3.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    length = 6,
    size: customSize,
    defaultValue,
    value,
    onChange,
    formatter,
    variant,
    disabled,
    status: customStatus,
    autoFocus,
    mask
  } = props, restProps = __rest2(props, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "variant", "disabled", "status", "autoFocus", "mask"]);
  if (true) {
    const warning = devUseWarning("Input.OTP");
    true ? warning(!(typeof mask === "string" && mask.length > 1), "usage", "`mask` prop should be a single character.") : void 0;
  }
  const {
    getPrefixCls,
    direction
  } = React3.useContext(ConfigContext);
  const prefixCls = getPrefixCls("otp", customizePrefixCls);
  const domAttrs = pickAttrs(restProps, {
    aria: true,
    data: true,
    attr: true
  });
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = otp_default(prefixCls, rootCls);
  const mergedSize = useSize_default((ctx) => customSize !== null && customSize !== void 0 ? customSize : ctx);
  const formContext = React3.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(formContext.status, customStatus);
  const proxyFormContext = React3.useMemo(() => Object.assign(Object.assign({}, formContext), {
    status: mergedStatus,
    hasFeedback: false,
    feedbackIcon: null
  }), [formContext, mergedStatus]);
  const containerRef = React3.useRef(null);
  const refs = React3.useRef({});
  React3.useImperativeHandle(ref, () => ({
    focus: () => {
      var _a;
      (_a = refs.current[0]) === null || _a === void 0 ? void 0 : _a.focus();
    },
    blur: () => {
      var _a;
      for (let i = 0; i < length; i += 1) {
        (_a = refs.current[i]) === null || _a === void 0 ? void 0 : _a.blur();
      }
    },
    nativeElement: containerRef.current
  }));
  const internalFormatter = (txt) => formatter ? formatter(txt) : txt;
  const [valueCells, setValueCells] = React3.useState(strToArr(internalFormatter(defaultValue || "")));
  React3.useEffect(() => {
    if (value !== void 0) {
      setValueCells(strToArr(value));
    }
  }, [value]);
  const triggerValueCellsChange = useEvent((nextValueCells) => {
    setValueCells(nextValueCells);
    if (onChange && nextValueCells.length === length && nextValueCells.every((c) => c) && nextValueCells.some((c, index) => valueCells[index] !== c)) {
      onChange(nextValueCells.join(""));
    }
  });
  const patchValue = useEvent((index, txt) => {
    let nextCells = _toConsumableArray(valueCells);
    for (let i = 0; i < index; i += 1) {
      if (!nextCells[i]) {
        nextCells[i] = "";
      }
    }
    if (txt.length <= 1) {
      nextCells[index] = txt;
    } else {
      nextCells = nextCells.slice(0, index).concat(strToArr(txt));
    }
    nextCells = nextCells.slice(0, length);
    for (let i = nextCells.length - 1; i >= 0; i -= 1) {
      if (nextCells[i]) {
        break;
      }
      nextCells.pop();
    }
    const formattedValue = internalFormatter(nextCells.map((c) => c || " ").join(""));
    nextCells = strToArr(formattedValue).map((c, i) => {
      if (c === " " && !nextCells[i]) {
        return nextCells[i];
      }
      return c;
    });
    return nextCells;
  });
  const onInputChange = (index, txt) => {
    var _a;
    const nextCells = patchValue(index, txt);
    const nextIndex = Math.min(index + txt.length, length - 1);
    if (nextIndex !== index) {
      (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
    }
    triggerValueCellsChange(nextCells);
  };
  const onInputActiveChange = (nextIndex) => {
    var _a;
    (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
  };
  const inputSharedProps = {
    variant,
    disabled,
    status: mergedStatus,
    mask
  };
  return wrapCSSVar(React3.createElement("div", Object.assign({}, domAttrs, {
    ref: containerRef,
    className: (0, import_classnames2.default)(prefixCls, {
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, cssVarCls, hashId)
  }), React3.createElement(FormItemInputContext.Provider, {
    value: proxyFormContext
  }, Array.from({
    length
  }).map((_, index) => {
    const key = `otp-${index}`;
    const singleValue = valueCells[index] || "";
    return React3.createElement(OTPInput_default, Object.assign({
      ref: (inputEle) => {
        refs.current[index] = inputEle;
      },
      key,
      index,
      size: mergedSize,
      htmlSize: 1,
      className: `${prefixCls}-input`,
      onChange: onInputChange,
      value: singleValue,
      onActiveChange: onInputActiveChange,
      autoFocus: index === 0 && autoFocus
    }, inputSharedProps));
  }))));
});
var OTP_default = OTP;

// node_modules/antd/es/input/Password.js
var React4 = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_classnames3 = __toESM(require_classnames());
init_omit();
init_ref();
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var defaultIconRender = (visible) => visible ? React4.createElement(EyeOutlined_default, null) : React4.createElement(EyeInvisibleOutlined_default, null);
var actionMap = {
  click: "onClick",
  hover: "onMouseOver"
};
var Password = React4.forwardRef((props, ref) => {
  const {
    disabled,
    action = "click",
    visibilityToggle = true,
    iconRender = defaultIconRender
  } = props;
  const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
  const [visible, setVisible] = (0, import_react2.useState)(() => visibilityControlled ? visibilityToggle.visible : false);
  const inputRef = (0, import_react2.useRef)(null);
  React4.useEffect(() => {
    if (visibilityControlled) {
      setVisible(visibilityToggle.visible);
    }
  }, [visibilityControlled, visibilityToggle]);
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
  const onVisibleChange = () => {
    if (disabled) {
      return;
    }
    if (visible) {
      removePasswordTimeout();
    }
    setVisible((prevState) => {
      var _a;
      const newState = !prevState;
      if (typeof visibilityToggle === "object") {
        (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, newState);
      }
      return newState;
    });
  };
  const getIcon = (prefixCls2) => {
    const iconTrigger = actionMap[action] || "";
    const icon = iconRender(visible);
    const iconProps = {
      [iconTrigger]: onVisibleChange,
      className: `${prefixCls2}-icon`,
      key: "passwordIcon",
      onMouseDown: (e) => {
        e.preventDefault();
      },
      onMouseUp: (e) => {
        e.preventDefault();
      }
    };
    return React4.cloneElement(React4.isValidElement(icon) ? icon : React4.createElement("span", null, icon), iconProps);
  };
  const {
    className,
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    size
  } = props, restProps = __rest3(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
  const {
    getPrefixCls
  } = React4.useContext(ConfigContext);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const prefixCls = getPrefixCls("input-password", customizePrefixCls);
  const suffixIcon = visibilityToggle && getIcon(prefixCls);
  const inputClassName = (0, import_classnames3.default)(prefixCls, className, {
    [`${prefixCls}-${size}`]: !!size
  });
  const omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
    type: visible ? "text" : "password",
    className: inputClassName,
    prefixCls: inputPrefixCls,
    suffix: suffixIcon
  });
  if (size) {
    omittedProps.size = size;
  }
  return React4.createElement(Input_default, Object.assign({
    ref: composeRef(ref, inputRef)
  }, omittedProps));
});
if (true) {
  Password.displayName = "Input.Password";
}
var Password_default = Password;

// node_modules/antd/es/input/TextArea.js
var React5 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_classnames4 = __toESM(require_classnames());
init_es2();
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var TextArea = (0, import_react3.forwardRef)((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    size: customizeSize,
    disabled: customDisabled,
    status: customStatus,
    allowClear,
    classNames: classes,
    rootClassName,
    className,
    style,
    styles,
    variant: customVariant
  } = props, rest = __rest4(props, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
  if (true) {
    const {
      deprecated
    } = devUseWarning("TextArea");
    deprecated(!("bordered" in props), "bordered", "variant");
  }
  const {
    getPrefixCls,
    direction,
    textArea
  } = React5.useContext(ConfigContext);
  const mergedSize = useSize_default(customizeSize);
  const disabled = React5.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = React5.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const innerRef = React5.useRef(null);
  React5.useImperativeHandle(ref, () => {
    var _a2;
    return {
      resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
      focus: (option) => {
        var _a3, _b2;
        triggerFocus((_b2 = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b2 === void 0 ? void 0 : _b2.textArea, option);
      },
      blur: () => {
        var _a3;
        return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
      }
    };
  });
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default(prefixCls, rootCls);
  const [variant, enableVariantCls] = useVariants_default("textArea", customVariant, bordered);
  const mergedAllowClear = getAllowClear_default(allowClear !== null && allowClear !== void 0 ? allowClear : textArea === null || textArea === void 0 ? void 0 : textArea.allowClear);
  return wrapCSSVar(React5.createElement(es_default, Object.assign({
    autoComplete: textArea === null || textArea === void 0 ? void 0 : textArea.autoComplete
  }, rest, {
    style: Object.assign(Object.assign({}, textArea === null || textArea === void 0 ? void 0 : textArea.style), style),
    styles: Object.assign(Object.assign({}, textArea === null || textArea === void 0 ? void 0 : textArea.styles), styles),
    disabled: mergedDisabled,
    allowClear: mergedAllowClear,
    className: (0, import_classnames4.default)(cssVarCls, rootCls, className, rootClassName, textArea === null || textArea === void 0 ? void 0 : textArea.className),
    classNames: Object.assign(Object.assign(Object.assign({}, classes), textArea === null || textArea === void 0 ? void 0 : textArea.classNames), {
      textarea: (0, import_classnames4.default)({
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large"
      }, hashId, classes === null || classes === void 0 ? void 0 : classes.textarea, (_a = textArea === null || textArea === void 0 ? void 0 : textArea.classNames) === null || _a === void 0 ? void 0 : _a.textarea),
      variant: (0, import_classnames4.default)({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: (0, import_classnames4.default)(`${prefixCls}-textarea-affix-wrapper`, {
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-textarea-show-count`]: props.showCount || ((_b = props.count) === null || _b === void 0 ? void 0 : _b.show)
      }, hashId)
    }),
    prefixCls,
    suffix: hasFeedback && React5.createElement("span", {
      className: `${prefixCls}-textarea-suffix`
    }, feedbackIcon),
    ref: innerRef
  })));
});
var TextArea_default = TextArea;

// node_modules/antd/es/input/index.js
var Input = Input_default;
Input.Group = Group_default;
Input.Search = Search_default;
Input.TextArea = TextArea_default;
Input.Password = Password_default;
Input.OTP = OTP_default;
var input_default = Input;

export {
  pickAttrs,
  TextArea_default,
  input_default
};
//# sourceMappingURL=chunk-T5I4W2HU.js.map
